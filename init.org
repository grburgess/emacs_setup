#+TITLE: Emacs configuration file
#+AUTHOR: J. Michael Burgess
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

  This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It is an attempt
  to keep my =~/.emacs.d= tidy, but still be able to keep it all in one
  file. I aim to briefly explain all my configurations as I go along!

* Configurations
** Meta

   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Any changes in the =init.el= will be overwritten by saving
   =init.org=. The =init.el= in this repo should not be tracked by git, and
   is replaced the first time Emacs is started (assuming it has been renamed
   to =~/.emacs.d=).

   Emacs can't load =.org=-files directly, but =org-mode= provides functions
   to extract the code blocks and write them to a file. There are multiple
   ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
   could just use =org-babel-load-file=, but I had problems with
   byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
   but the git commits got a little messy. So here is a new approach.

   When this configuration is loaded for the first time, the ~init.el~ is
   the file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
   ;; This file replaces itself with the actual configuration at first run.


   ;; We can't tangle without org!
   (require 'org)
   ;;(setq my_dir "/Users/jburgess/.emacs.d")

   ;; Open the configuration
   (find-file (concat user-emacs-directory "init.org"))
   ;; tangle it
   (org-babel-tangle)
   ;; load it
   (load-file (concat user-emacs-directory "init.el"))
   ;; finally byte-compile it
   ;;(byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   It tangles the org-file, so that this file is overwritten with the actual
   configuration.

   There is no reason to track the =init.el= that is generated; by running
   the following command =git= will not bother tracking it:


   If one wishes to make changes to the repo-version of =init.el= start
   tracking again with:


   I want lexical scoping for the init-file, which can be specified in the
   header. The first line of the configuration is as follows:

   #+BEGIN_SRC emacs-lisp
   ;;; -*- lexical-binding: t -*-
   #+END_SRC

   The =init.el= should (after the first run) mirror the source blocks in
   the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
   extracts the code blocks from the current file into a source-specific
   file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp

   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         )))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   I'd like to keep a few settings private, so we load a =private.el= if it
   exists after the init-file has loaded.

   #+BEGIN_SRC emacs-lisp

   (setq custom-file "~/.emacs.d/custom.el")
   (load custom-file)
   (setq shell-file-name "/bin/bash")

   #+END_SRC




** Packages

   Managing extensions for Emacs is simplified using =package= which is
   built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl= is a library that contains many functions from
   Common Lisp, and comes in handy quite often, so we want to make sure it's
   loaded, along with =package=, which is obviously needed.

   #+BEGIN_SRC emacs-lisp
   (require 'cl)
   (require 'package)
   (package-initialize)
   (package-refresh-contents)
   #+END_SRC

   Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
   archive and is well maintained.

   #+BEGIN_SRC emacs-lisp

   (setq package-check-signiture nil)

   (setq package-archives '(("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
                            ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")))


   ;; (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
   ;; (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
   ;; (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)


   #+END_SRC

   The configuration assumes that the packages listed below are
   installed. To ensure we install missing packages if they are missing.

   #+BEGIN_SRC emacs-lisp
   (let* ((package--builtins nil)
          (packages
           '(auto-compile         ; automatically compile Emacs Lisp libraries
             company              ; Modular text completion framework
             focus                ; Dim color of text in surrounding sections
             idle-require         ; load elisp libraries while Emacs is idle
             jedi                 ; Python auto-completion for Emacs
             magit                ; control Git from Emacs
             markdown-mode        ; Emacs Major mode for Markdown-formatted files
             multiple-cursors     ; Multiple cursors for Emacs
             olivetti             ; Minor mode for a nice writing environment
             org                  ; Outline-based notes management and organizer
             org-ref              ; citations bibliographies in org-mode
             paredit              ; minor mode for editing parentheses
             pdf-tools            ; Emacs support library for PDF files
             slime                ; Superior Lisp Interaction Mode for Emacs
             diminish
             crux
             org-cliplink
             company-jedi
             which-key
             iedit
             easy-jekyll
             bug-hunter
             cyberpunk-2019-theme
             cyberpunk-theme
             doom-modeline
             doom-themes
             git-gutter-fringe
             org-bullets
             abyss-theme
             afternoon-theme
             ample-theme
             arjen-grey-theme
             atom-dark-theme
             badger-theme
             birds-of-paradise-plus-theme
             calmer-forest-theme
             constant-theme
             dakrone-theme
             dark-krystal-theme
             dark-mint-theme
             darkmine-theme
             darkokai-theme
             distinguished-theme
             exotica-theme
             flatui-dark-theme
             forest-blue-theme
             gotham-theme
             grandshell-theme
             gruber-darker-theme
             hamburg-theme
             idea-darkula-theme
             klere-theme
             kooten-theme
             liso-theme
             lush-theme
             madhat2r-theme
             majapahit-theme
             metalheart-theme
             monochrome-theme
             monokai-alt-theme
             noctilux-theme
             northcode-theme
             nyx-theme
             paganini-theme
             planet-theme
             reykjavik-theme
             rimero-theme
             sexy-monochrome-theme
             smart-mode-line-atom-one-dark-theme
             soft-charcoal-theme
             soothe-theme
             toxi-theme
             twilight-anti-bright-theme
             warm-night-theme
             zeno-theme
             zerodark-theme
             zweilight-theme
             alect-themes
             apropospriate-theme
             arc-dark-theme
             atom-one-dark-theme
             darktooth-theme
             eziam-theme
             foggy-night-theme
             minimal-theme
             mood-one-theme
             nimbus-theme
             nova-theme
             overcast-theme
             seti-theme
             srcery-theme
             tablist
             magit-popup
             neotree
             browse-kill-ring
             spotify
             shell-pop
             use-package
             magithub
             smart-mode-line-powerline-theme
             moe-theme
             undo-tree
             mu4e-maildirs-extension
             mu4e-conversation
             mutt-mode
             blacken
             company-reftex
             company-auctex
             ace-jump-mode
             sublime-themes
             auto-complete-auctex
             sublimity
             yasnippet
             yasnippet-classic-snippets
             standoff-mode
             elpygen
             projectile
             auto-complete
             smex
             yasnippet-snippets
             yaml-mode
             stan-snippets
             ssh
             sphinx-doc
             spacemacs-theme
             rope-read-mode
             rainbow-identifiers
             rainbow-delimiters
             python-docstring
             origami
             omtose-phellack-theme
             markdown-mode
             magit
             kaolin-themes
             js2-mode
             highlight-numbers
             highlight-indent-guides
             gist
             flymake-python-pyflakes
             flycheck
             ess
             elpy
             dockerfile-mode
             cython-mode
             context-coloring
             beacon

             company-irony-c-headers
             color-identifiers-mode
             colonoscopy-theme
             auctex
             )))
                                           ; Display available keybindings in popup
     (ignore-errors ;; This package is only relevant for Mac OS X.

       (let ((packages (remove-if 'package-installed-p packages)))
         (when packages
           ;; Install uninstalled packages
           (package-refresh-contents)
           (mapc 'package-install packages)))))
   #+END_SRC

** Mac OS X

   I run this configuration mostly on Mac OS X, so we need a couple of
   settings to make things work smoothly. In the package section
   =exec-path-from-shell= is included (only if you're running OS X), this is
   to include environment-variables from the shell. It makes using Emacs
   along with external processes a lot simpler. I also prefer using the
   =Command=-key as the =Meta=-key.

   #+BEGIN_SRC emacs-lisp

   (defun copy-from-osx ()
     (shell-command-to-string "pbpaste"))

   (defun paste-to-osx (text &optional push)
     (let ((process-connection-type nil))
       (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
         (process-send-string proc text)
         (process-send-eof proc))))

   (setq interprogram-cut-function 'paste-to-osx)
   (setq interprogram-paste-function 'copy-from-osx)

   #+END_SRC

** Sane defaults

   These are what /I/ consider to be saner defaults.

   We can set variables to whatever value we'd like using =setq=.



   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp

   (setq debug-on-error t)

   (menu-bar-mode 0)

   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (defvar user-temporary-file-directory
     "~/.emacs-autosaves/")

   (make-directory user-temporary-file-directory t)
   (setq backup-by-copying t)
   (setq backup-directory-alist
         `(("." . ,user-temporary-file-directory)
           (tramp-file-name-regexp nil)))
   (setq auto-save-list-file-prefix
         (concat user-temporary-file-directory ".auto-saves-"))
   (setq auto-save-file-name-transforms
         `((".*" ,user-temporary-file-directory t)))



   #+END_SRC

   Set =utf-8= as preferred coding system.

   #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
   #+END_SRC

   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   Automaticly revert =doc-view=-buffers when the file changes on disk.

   #+BEGIN_SRC emacs-lisp
                                           ;  (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

** Modes

   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.

   #+BEGIN_SRC emacs-lisp

   (setq inhibit-splash-screen t)
   ;;(add-hook 'after-init-hook 'global-color-identifiers-mode)
   (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

   (require 'highlight-indent-guides)
   (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
   (setq highlight-indent-guides-auto-enabled nil)
   (setq highlight-indent-guides-method 'character)

   (setq highlight-indent-guides-auto-enabled nil)

   (set-face-background 'highlight-indent-guides-odd-face "seagreen")
   (set-face-background 'highlight-indent-guides-even-face "seagreen")
   (set-face-foreground 'highlight-indent-guides-character-face "seagreen")


   (dolist (mode
            '(tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              ))
     (funcall mode 0))
   #+END_SRC

   Let's apply the same technique for enabling modes that are disabled by
   default.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              dirtrack-mode                ; directory tracking in *shell*
              global-company-mode          ; Auto-completion everywhere
              global-prettify-symbols-mode ; Greek letters should look gree
              show-paren-mode              ; Highlight matching parentheses
              which-key-mode))             ; Available keybindings in popup
     (funcall mode 1))

   (when (version< emacs-version "24.4")
     (eval-after-load 'auto-compile
       '((auto-compile-on-save-mode 1))))  ; compile .el files on save
   #+END_SRC

** Visual

   Change the color-theme to =forrest=.

   #+BEGIN_SRC emacs-lisp
   (load-theme 'kaolin-aurora t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (lexical-let ((themes '#1=( kaolin-temple granger kaolin-galaxy 
					       noctilux doom-moonlight doom-city-lights
					    sexy-monochrome lush
					       cyberpunk cyberpunk-2019 kaolin-aurora . #1#)))
       (lambda ()
	 (interactive)
	 ;; Rotates the thme cycle and changes the current theme.
	 (load-theme (car (setq themes (cdr themes))) t) )))
   #+END_SRC

   Some nice visual modes
   #+BEGIN_SRC emacs-lisp
   (require 'doom-themes)

   (beacon-mode 1)
   (setq beacon-color "#1BFFA5")
   (setq beacon-push-mark 60)
   (require 'sublimity)
   (require 'sublimity-attractive)
   (sublimity-mode 1)

   (setq sublimity-attractive-centering-width 130)

   ;; Enable flashing mode-line on errors
   (doom-themes-visual-bell-config)

   ;; Corrects (and improves) org-mode's native fontification.
   (doom-themes-org-config)

   ;; (require 'sublimity-scroll)

   ;; (setq sublimity-scroll-weight 10
   ;;       sublimity-scroll-drift-length 10)


   #+END_SRC



   #+BEGIN_SRC emacs-lisp
   (require 'all-the-icons)
   (require 'doom-modeline)
   (doom-modeline-mode 1)

   ;; Whether display icons in mode-line or not.
   (setq doom-modeline-icon t)

   ;; Whether display the icon for major mode. It respects `doom-modeline-icon'.
   (setq doom-modeline-major-mode-icon t)


   ;; Whether display color icons for `major-mode'. It respects
   ;; `doom-modeline-icon' and `all-the-icons-color-icons'.
   (setq doom-modeline-major-mode-color-icon t)

   ;; Whether display icons for buffer states. It respects `doom-modeline-icon'.
   (setq doom-modeline-buffer-state-icon t)

   ;; Whether display buffer modification icon. It respects `doom-modeline-icon'
   ;; and `doom-modeline-buffer-state-icon'.
   (setq doom-modeline-buffer-modification-icon t)

   ;; Whether display minor modes in mode-line or not.
   (setq doom-modeline-minor-modes t)

   ;; If non-nil, a word count will be added to the selection-info modeline segment.
   (setq doom-modeline-enable-word-count nil)

   ;; If non-nil, only display one number for checker information if applicable.
   (setq doom-modeline-checker-simple-format t)

   ;; The maximum displayed length of the branch name of version control.
   (setq doom-modeline-vcs-max-length 12)


   ;; Whether display perspective name or not. Non-nil to display in mode-line.
   (setq doom-modeline-persp-name t)

   ;; Whether display `lsp' state or not. Non-nil to display in mode-line.
   (setq doom-modeline-lsp t)

   ;; Whether display github notifications or not. Requires `ghub` package.
   (setq doom-modeline-github nil)

   ;; The interval of checking github.
   (setq doom-modeline-github-interval (* 30 60))

   ;; Whether display environment version or not
   (setq doom-modeline-env-version t)
   ;; Or for individual languages
   (setq doom-modeline-env-enable-python t)
   (setq doom-modeline-env-enable-ruby t)






   ;; Change the executables to use for the language version string
   (setq doom-modeline-env-python-executable "python")
   (setq doom-modeline-env-ruby-executable "ruby")

   ;; Whether display mu4e notifications or not. Requires `mu4e-alert' package.
   (setq doom-modeline-mu4e nil)

   ;; Whether display irc notifications or not. Requires `circe' package.
   (setq doom-modeline-irc nil)

   ;; Function to stylize the irc buffer names.
   (setq doom-modeline-irc-stylize 'identity)



   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (setq ibuffer-saved-filter-groups
         '(("home"
            ("emacs-config" (or (filename . ".emacs.d")
                                (filename . ".init.org")))
            ("Org" (or (mode . org-mode)
                       (filename . "OrgMode")))
            ("latex" (or (mode . tex-mode)
                         (mode . auctex-mode)
                         (mode . latex-mode))
             )
            ("stan" (mode . stan-mode) )

            ("python" (mode . python-mode))
            ("Magit" (name . "\*magit"))
            ("Help" (or (name . "\*Help\*")
                        (name . "\*Apropos\*")
                        (name . "\*info\*"))))))

   (add-hook 'ibuffer-mode-hook
             '(lambda ()
                (ibuffer-switch-to-saved-filter-groups "home")))



   #+END_SRC



   New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   #+END_SRC

** Completion

   [[https://github.com/auto-complete/auto-complete][Auto-Complete]] has been a part of my config for years, but I want to try
   out [[http://company-mode.github.io/][company-mode]]. If I code in an environment with good completion, I've
   made an habit of trying to /guess/ function-names, and looking at the
   completions for the right one. So I want a pretty aggressive completion
   system, hence the no delay settings and short prefix length.

   #+BEGIN_SRC emacs-lisp

   (add-hook 'after-init-hook 'global-company-mode)
                                           ;   (add-to-list 'load-path "path/to/company-auctex.el")
   (require 'company-auctex)
   (company-auctex-init)


   (setq company-idle-delay 0
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance))

   (require 'yasnippet)
   (yas-global-mode 1)
   (defun check-expansion ()
     (save-excursion
       (if (looking-at "\\_>") t
         (backward-char 1)
         (if (looking-at "\\.") t
           (backward-char 1)
           (if (looking-at "->") t nil)))))

   (defun do-yas-expand ()
     (let ((yas/fallback-behavior 'return-nil))
       (yas/expand)))

   (defun tab-indent-or-complete ()
     (interactive)
     (if (minibufferp)
         (minibuffer-complete)
       (if (or (not yas/minor-mode)
               (null (do-yas-expand)))
           (if (check-expansion)
               (company-complete-common)
             (indent-for-tab-command)))))



   (require 'stan-mode)

   (with-eval-after-load 'stan

     (require 'stan-snippets)
     (yas-global-mode 1)
     (add-hook 'stan-mode-hook '(lambda () (yas-minor-mode)))

     )


   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defun org-keyword-backend (command &optional arg &rest ignored)
     (interactive (list 'interactive))
     (cl-case command
       (interactive (company-begin-backend 'org-keyword-backend))
       (prefix (and (eq major-mode 'org-mode)
                    (cons (company-grab-line "^#\\+\\(\\w*\\)" 1)
                          t)))
       (candidates (mapcar #'upcase
                           (cl-remove-if-not
                            (lambda (c) (string-prefix-p arg c))
                            (pcomplete-completions))))
       (ignore-case t)
       (duplicates t)))

   (add-to-list 'company-backends 'org-keyword-backend)



   #+END_SRC


** IDO/SMEX/ACE

   Just some jumping around and easy menus

   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-x") 'smex)
   (global-set-key (kbd "M-X") 'smex-major-mode-commands)
   ;; This is your old M-x.
   (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
   #+END_SRC



   #+BEGIN_SRC emacs-lisp
   (require 'ido)
   (ido-mode t)
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
   (autoload
     'ace-jump-mode
     "ace-jump-mode"
     "Emacs quick move minor mode"
     t)
   ;; you can select the key you prefer to
   ;;(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
   ;;(define-key global-map (kbd "C-c C-c SPC") 'ace-jump-line-mode)

   ;; (define-key global-map (kbd "C-o SPC") 'ace-jump-line-mode)
   #+END_SRC


** Flyspell

   Flyspell offers on-the-fly spell checking. We can enable flyspell for all
   text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   ;;(add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].


** Org

   I use =org-agenda= along with =org-capture= for appointments and such.

   #+BEGIN_SRC emacs-lisp

   (add-hook 'org-mode-hook 'turn-on-auto-fill)

   (setq org-directory "~/org")
   (setq org-agenda-files (list "~/org/"))
   (setq org-agenda-file-regexp "\\`[^.].*\\.org\\|.todo\\'")
   (setq org-mobile-inbox-for-pull "~/org/flagged.org")
   ;; Set to <your Dropbox root directory>/MobileOrg.
   (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
   (global-set-key "\C-cl" 'org-store-link)
   (global-set-key "\C-ca" 'org-agenda)
   (setq org-todo-keywords
         '((sequence "TODO" "READ" "RESEARCH" "|" "DONE" "DELEGATED" )))




                                           ;(setq org-todo-keywords '((sequence "☛ TODO(t)" "|" "<img draggable="false" class="emoji" alt="✔" src="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/2714.svg"> DONE(d)")
                                           ;(sequence "⚑ WAITING(w)" "|")
                                           ;(sequence "|" "✘ CANCELED(c)")))


   (require 'org-bullets)
   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))


   (setq org-todo-keyword-faces
         '(("TODO" . org-warning) ("READ" . "yellow") ("RESEARCH" . (:foreground "blue" :weight bold))
           ("CANCELED" . (:foreground "pink" :weight bold))
           ("WRITING" . (:foreground "red" :weight bold))
           ("RECIEVED" . (:foreground "red" :background "green" :weight bold))
           ("SUBMITTED" . (:foreground "blue"))
           ("ACCEPTED" . (:foreground "green"))


           ))

        ;;; ORG TEMPLATES
   (setq org-default-notes-file (concat org-directory "/notes.org"))
   (define-key global-map "\C-cc" 'org-capture)


   (setq org-capture-templates
         '(("t" "Todo" entry (file "~/org/notes.org")
            "* TODO %?\n%U" :empty-lines 1)

           ("l" "Logbook entry" entry (file+datetree "logbook-work.org") "** %U - %^{Activity}  :LOG:")


           ("P" "Research project" entry (file "~/org/projects.org")
            "* TODO %^{Project title} :%^G:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%^{Project description}\n** TODO Literature review\n** TODO %?\n** TODO Summary\n** TODO Reports\n** Ideas\n" :clock-in t :clock-resume t)

           ("a" "Research Article" entry(file+headline "~/org/publications.org" "Working articles") "** WRITING %^{Title}\n\t-Added: %U\n   :LOGBOOK:\n   :END:\n")

           ("r" "Ref. Report" entry(file+headline "~/org/publications.org" "Referee reports") "** WRITING %^{Title}\n\t-Added: %U\n   :LOGBOOK:\n   :END:\n")

           ("c" "Coding tips" entry(file+headline "~/org/coding.org" "Refile") "** READ %^{description} %^g  \n\t-Added: %U\n   :LOGBOOK:\n   :END:\n")

                                           ;    ("C" "Cliplink capture code" entry (file+headline  "~/org/coding.org" "Refile" ) "** READ %^{description} %^g  %(org-cliplink-capture) \n\t-Added: %U\n   :LOGBOOK:\n   :END:\n" :empty-lines 1)

           ("f" "Fitting" entry(file+headline "~/org/fitting.org" "Refile") "** READ %^{description}  %^g  \n\t-Added: %U\n   :LOGBOOK:\n   :END:\n")

                                           ;       ("F" "Cliplink capture fitting" entry (file+headline  "~/org/fitting.org" "Refile" ) "** READ %^{description} %^g  %(org-cliplink-capture) \n\t-Added: %U\n   :LOGBOOK:\n   :END:\n" :empty-lines 1)

           )
         )



   #+END_SRC

   When editing org-files with source-blocks, we want the source blocks to
   be themed as they would in their native mode.

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC

   This is quite an ugly fix for allowing code markup for expressions like
   ="this string"=, because the quotation marks causes problems.

   #+BEGIN_SRC emacs-lisp
   ;;(require 'org)
   (eval-after-load "org"
     '(progn
        (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
        (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp



   #+END_SRC

** Jekyll
   Setup for easy blogging

   #+BEGIN_SRC emacs-lisp

   (setq easy-jekyll-basedir "~/coding/grburgess.github.io/")
   (setq easy-jekyll-url "https://grburgess.github.io")
   ;; (setq easy-jekyll-sshdomain "blogdomain")
   ;; (setq easy-jekyll-root "/home/blog/")
   ;; (setq easy-jekyll-previewtime "300")



   #+END_SRC

** Interactive functions
   <<sec:defuns>>

   =just-one-space= removes all whitespace around a point - giving it a
   negative argument it removes newlines as well. We wrap a interactive
   function around it to be able to bind it to a key. In Emacs 24.4
   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   when run in succession it cycles between one, zero and the original
   number of spaces.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-spacing-delete-newlines ()
     "Removes whitespace before and after the point."
     (interactive)
     (if (version< emacs-version "24.4")
         (just-one-space -1)
       (cycle-spacing -1)))
   #+END_SRC

   Often I want to find other occurrences of a word I'm at, or more
   specifically the symbol (or tag) I'm at. The
   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   I don't want to be bothered with the =isearch= interface. Rather jump
   quickly between occurrences of a symbol, or if non is found, don't do
   anything.

   #+BEGIN_SRC emacs-lisp
   (defun jump-to-symbol-internal (&optional backwardp)
     "Jumps to the next symbol near the point if such a symbol
   exists. If BACKWARDP is non-nil it jumps backward."
     (let* ((point (point))
            (bounds (find-tag-default-bounds))
            (beg (car bounds)) (end (cdr bounds))
            (str (isearch-symbol-regexp (find-tag-default)))
            (search (if backwardp 'search-backward-regexp
                      'search-forward-regexp)))
       (goto-char (if backwardp beg end))
       (funcall search str nil t)
       (cond ((<= beg (point) end) (goto-char point))
             (backwardp (forward-char (- point beg)))
             (t  (backward-char (- end point))))))

   (defun jump-to-previous-like-this ()
     "Jumps to the previous occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal t))

   (defun jump-to-next-like-this ()
     "Jumps to the next occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal))
   #+END_SRC

   I sometimes regret killing the =*scratch*=-buffer, and have realized I
   never want to actually kill it. I just want to get it out of the way, and
   clean it up. The function below does just this for the
   =*scratch*=-buffer, and works like =kill-this-buffer= for any other
   buffer. It removes all buffer content and buries the buffer (this means
   making it the least likely candidate for =other-buffer=).

   #+BEGIN_SRC emacs-lisp
   (defun kill-this-buffer-unless-scratch ()
     "Works like `kill-this-buffer' unless the current buffer is the
   ,*scratch* buffer. In witch case the buffer content is deleted and
   the buffer is buried."
     (interactive)
     (if (not (string= (buffer-name) "*scratch*"))
         (kill-this-buffer)
       (delete-region (point-min) (point-max))
       (switch-to-buffer (other-buffer))
       (bury-buffer "*scratch*")))
   #+END_SRC

   To duplicate either selected text or a line we define this interactive
   function.

   #+BEGIN_SRC emacs-lisp
   (defun duplicate-thing (comment)
     "Duplicates the current line, or the region if active. If an argument is
   given, the duplicated region will be commented out."
     (interactive "P")
     (save-excursion
       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
             (end   (if (region-active-p) (region-end) (point-at-eol))))
         (goto-char end)
         (unless (region-active-p)
           (newline))
         (insert (buffer-substring start end))
         (when comment (comment-region start end)))))
   #+END_SRC

   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   Org mode does currently not support synctex (which enables you to jump from
   a point in your TeX-file to the corresponding point in the pdf), and it
   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

   Calling this function from an org-buffer jumps to the corresponding section
   in the exported pdf (given that the pdf-file exists), using pdf-tools.

   #+BEGIN_SRC emacs-lisp
   (defun org-sync-pdf ()
     (interactive)
     (let ((headline (nth 4 (org-heading-components)))
           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
       (when (file-exists-p pdf)
         (find-file-other-window pdf)
         (pdf-links-action-perform
          (cl-find headline (pdf-info-outline pdf)
                   :key (lambda (alist) (cdr (assoc 'title alist)))
                   :test 'string-equal)))))
   #+END_SRC


   #+BEGIN_SRC emacs-lisp

   (defun xah-space-to-newline ()
     "Replace space sequence to a newline char.
   Works on current block or selection.

   URL `http://ergoemacs.org/emacs/emacs_space_to_newline.html'
   Version 2017-08-19"
     (interactive)
     (let* ( $p1 $p2 )
       (if (use-region-p)
           (progn
             (setq $p1 (region-beginning))
             (setq $p2 (region-end)))
         (save-excursion
           (if (re-search-backward "\n[ \t]*\n" nil "move")
               (progn (re-search-forward "\n[ \t]*\n")
                      (setq $p1 (point)))
             (setq $p1 (point)))
           (re-search-forward "\n[ \t]*\n" nil "move")
           (skip-chars-backward " \t\n" )
           (setq $p2 (point))))
       (save-excursion
         (save-restriction
           (narrow-to-region $p1 $p2)
           (goto-char (point-min))
           (while (re-search-forward " +" nil t)
             (replace-match "\n" ))))))
   #+END_SRC


** Advice

   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

* Mode specific

** Python


   I use elpy for python.

   #+BEGIN_SRC emacs-lisp
   (elpy-enable)

   (with-eval-after-load 'elpy

     (add-hook 'python-mode-hook (lambda ()
                                   (require 'sphinx-doc)
                                   (sphinx-doc-mode t)))

     ;; Activate python highlighting for PYX and PPL files
     (add-to-list 'auto-mode-alist '("\\.pyx\\'" . cython-mode))
     (add-to-list 'auto-mode-alist '("\\.ppl\\'" . cython-mode))

     (add-to-list 'company-backends 'company-jedi)

     (define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand)
     (define-key global-map (kbd "C-c o") 'iedit-mode)


     (add-hook 'python-mode-hook 'elpy-mode)

     (remove-hook 'elpy-modules 'elpy-module-flymake)
     (add-hook 'elpy-mode-hook 'flycheck-mode)
     (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1)))

     (defun elpy-goto-definition-or-rgrep ()
       "Go to the definition of the symbol at point, if found. Otherwise, run `elpy-rgrep-symbol'."
       (interactive)
       (ring-insert find-tag-marker-ring (point-marker))
       (condition-case nil (elpy-goto-definition)
         (error (elpy-rgrep-symbol
                 ((concat ) "\\(def\\|class\\)\s" (thing-at-point 'symbol) "(")))))

     (define-key elpy-mode-map (kbd "M-.") 'elpy-goto-definition-or-rgrep)


     (setq python-shell-interpreter "ipython"
           python-shell-interpreter-args "-i --simple-prompt")



     )





   #+END_SRC

** LaTeX and org-mode LaTeX export

   LaTeX Setup
   #+BEGIN_SRC emacs-lisp
   (load "auctex.el" nil t t)
   (with-eval-after-load 'latex

     (auto-fill-mode 1)
     (require 'reftex)
     (setq-default TeX-engine 'xetex)
     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)

     (add-hook 'LaTeX-mode-hook 'reftex-mode)
     (add-hook 'LaTeX-mode-hook 'visual-line-mode)
     (add-hook 'LaTeX-mode-hook #'TeX-fold-mode) ;; Automatically activate TeX-fold-mode.
     (add-hook 'LaTeX-mode-hook 'TeX-fold-buffer t)

     (add-hook 'LaTeX-mode-hook 'flyspell-mode)
     (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
                                           ;  (add-hook 'LaTeX-mode-hook 'sublimity-mode 1)
     (setq reftex-plug-into-AUCTeX t)
     (setq reftex-default-bibliography '("/Users/jburgess/Documents/complete_bib.bib"))


     )

   #+END_SRC
** Compilation

   I often run ~latexmk -pdf -pvc~ in a compilation buffer, which recompiles
   the latex-file whenever it is changed. This often results in annoyingly
   large compilation buffers; the following snippet limits the buffer size in
   accordance with ~comint-buffer-maximum-size~, which defaults to 1024 lines.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'compilation-filter-hook 'comint-truncate-buffer)
   #+END_SRC

** Shell

   Inspired by [[https://github.com/torenord/.emacs.d][torenord]], I maintain quick access to shell buffers with bindings
   ~M-1~ to ~M-9~. In addition, the ~M-§~ (on an international English
   keyboard) is bound toggle between the last visited shell, and the last
   visited non-shell buffer. The following functions facilitate this, and are
   bound in the [[Key bindings]] section.

   #+BEGIN_SRC emacs-lisp
   (lexical-let ((last-shell ""))
     (defun toggle-shell ()
       (interactive)
       (cond ((string-match-p "^\\*shell<[1-9][0-9]*>\\*$" (buffer-name))
              (goto-non-shell-buffer))
             ((get-buffer last-shell) (switch-to-buffer last-shell))
             (t (shell (setq last-shell "*shell<1>*")))))

     (defun switch-shell (n)
       (let ((buffer-name (format "*shell<%d>*" n)))
         (setq last-shell buffer-name)
         (cond ((get-buffer buffer-name)
                (switch-to-buffer buffer-name))
               (t (shell buffer-name)
                  (rename-buffer buffer-name)))))

     (defun goto-non-shell-buffer ()
       (let* ((r "^\\*shell<[1-9][0-9]*>\\*$")
              (shell-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
              (non-shells (cl-remove-if shell-buffer-p (buffer-list))))
         (when non-shells
           (switch-to-buffer (first non-shells))))))
   #+END_SRC

   Don't query whether or not the ~shell~-buffer should be killed, just kill
   it.

   #+BEGIN_SRC emacs-lisp
   (defadvice shell (after kill-with-no-query nil activate)
     (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil))
   #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   The =clear-shell= should only be bound in =comint-mode=, which is a mode
   most shell and REPL's is derived from.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC

** Lisp

   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(cider-repl-mode
                   clojure-mode
                   ielm-mode
                   geiser-repl-mode
                   slime-repl-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC

*** Clojure

    #+BEGIN_SRC emacs-lisp
    (add-hook 'cider-repl-mode-hook (lambda () (local-set-key (kbd "C-l") 'cider-repl-clear-buffer)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
    (setq cider-cljs-lein-repl
          "(do (require 'figwheel-sidecar.repl-api)
               (figwheel-sidecar.repl-api/start-figwheel!)
               (figwheel-sidecar.repl-api/cljs-repl))")
    #+END_SRC

*** Common lisp

    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
    provides code evaluation and other great features, a must have for a
    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
    and you can install Slime following the instructions from the site along
    with this snippet.

    #+BEGIN_SRC emacs-lisp
    (defun activate-slime-helper ()
      (when (file-exists-p "~/.quicklisp/slime-helper.el")
        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
        (define-key slime-repl-mode-map (kbd "C-l")
          'slime-repl-clear-buffer))
      (remove-hook 'lisp-mode-hook #'activate-slime-helper))

    (add-hook 'lisp-mode-hook #'activate-slime-helper)
    #+END_SRC

    We can specify what Common Lisp program Slime should use (I use SBCL).

    #+BEGIN_SRC emacs-lisp
    (setq inferior-lisp-program "sbcl")
    #+END_SRC

    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].

    #+BEGIN_SRC emacs-lisp
    (setq lisp-loop-forms-indentation   6
          lisp-simple-loop-indentation  2
          lisp-loop-keyword-indentation 6)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    #+END_SRC

*** Scheme

    [[http://www.nongnu.org/geiser/][Geiser]] provides features similar to Slime for Scheme editing. Everything
    works pretty much out of the box, we only need to add auto completion,
    and specify which scheme-interpreter we prefer.

    #+BEGIN_SRC emacs-lisp
    (eval-after-load "geiser"
      '(setq geiser-active-implementations '(guile)))
    #+END_SRC

** Java and C

   The =c-mode-common-hook= is a general hook that work on all C-like
   languages (C, C++, Java, etc...). I like being able to quickly compile
   using =C-c C-c= (instead of =M-x compile=), a habit from =latex-mode=.

   #+BEGIN_SRC emacs-lisp
   (defun c-setup ()
     (local-set-key (kbd "C-c C-c") 'compile))

   (add-hook 'c-mode-common-hook 'c-setup)
   #+END_SRC

   Some statements in Java appear often, and become tedious to write
   out. We can use abbrevs to speed this up.

   #+BEGIN_SRC emacs-lisp
   (define-abbrev-table 'java-mode-abbrev-table
     '(("psv" "public static void main(String[] args) {" nil 0)
       ("sopl" "System.out.println" nil 0)
       ("sop" "System.out.printf" nil 0)))
   #+END_SRC

   To be able to use the abbrev table defined above, =abbrev-mode= must be
   activated.

   #+BEGIN_SRC emacs-lisp
   (defun java-setup ()
     (abbrev-mode t)
     (setq-local compile-command (concat "javac " (buffer-name))))

   (add-hook 'java-mode-hook 'java-setup)
   #+END_SRC

** Markdown

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC

   I sometimes use a specialized markdown format, where inline math-blocks
   can be achieved by surrounding a LaTeX formula with =$math$= and
   =$/math$=. Writing these out became tedious, so I wrote a small function.

   #+BEGIN_SRC emacs-lisp
   (defun insert-markdown-inline-math-block ()
     "Inserts an empty math-block if no region is active, otherwise wrap a
   math-block around the region."
     (interactive)
     (let* ((beg (region-beginning))
            (end (region-end))
            (body (if (region-active-p) (buffer-substring beg end) "")))
       (when (region-active-p)
         (delete-region beg end))
       (insert (concat "$math$ " body " $/math$"))
       (search-backward " $/math$")))
   #+END_SRC

   Most of my writing in this markup is in Norwegian, so the dictionary is
   set accordingly. The markup is also sensitive to line breaks, so
   =auto-fill-mode= is disabled. Of course we want to bind our lovely
   function to a key!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'markdown-mode-hook
             (lambda ()
               (auto-fill-mode 0)
               (visual-line-mode 1)
               (ispell-change-dictionary "american")
               (local-set-key (kbd "C-c b") 'insert-markdown-inline-math-block)) t)
   #+END_SRC

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.


  #+BEGIN_SRC emacs-lisp
  ;; join the line below with the current line
  (global-set-key (kbd "M-j") (lambda () (interactive)
                                (join-line -1)))
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (autoload 'ibuffer "ibuffer" "List buffers." t)

  #+END_SRC


  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC

** Bindings for [[http://magit.github.io][Magit]]

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "C-c m") 'magit-status)
   #+END_SRC

** Bindings for [[http://company-mode.github.io/][company-mode]]

   #+BEGIN_SRC emacs-lisp
   (define-key company-active-map (kbd "C-d") 'company-show-doc-buffer)
   (define-key company-active-map (kbd "C-n") 'company-select-next)
   (define-key company-active-map (kbd "C-p") 'company-select-previous)
   #+END_SRC
** Bindings for crux
   #+BEGIN_SRC emacs-lisp

   ;; crux
   (global-set-key   [remap move-beginning-of-line] #'crux-move-beginning-of-line)
   (global-set-key   (kbd "C-<backspace>") #'crux-kill-line-backwards)
   (global-set-key   [remap kill-whole-line] #'crux-kill-whole-line)
   (global-set-key    [(shift return)] #'crux-smart-open-line)
   (global-set-key   (kbd "C-c I")     #'crux-find-user-init-file)

   #+END_SRC

** Bindings for built-ins

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
   (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
   (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
   (define-key custom-bindings-map (kbd "M-]")         'other-frame)

   (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
   (define-key custom-bindings-map (kbd "C-x m")       'mu4e)
   (define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
   (define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
   (define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
   (define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
   (define-key custom-bindings-map (kbd "C-c t")
     (lambda () (interactive) (org-agenda nil "n")))
   #+END_SRC

** Bindings for functions defined [[sec:defuns][above]].

   #+BEGIN_SRC emacs-lisp
   (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
   (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
   ;; (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
   ;; (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
   (define-key custom-bindings-map (kbd "C-x a ") 'ace-jump-mode)
   (define-key custom-bindings-map (kbd "M-z") 'tab-indent-or-complete)
   (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
   (define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
   (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
   (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
   (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
   (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
   (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
   (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
   (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
   (define-key custom-bindings-map (kbd "M-§")     'toggle-shell)
   (dolist (n (number-sequence 1 9))
     (global-set-key (kbd (concat "M-" (int-to-string n)))
                     (lambda () (interactive) (switch-shell n))))
   ;; (define-key custom-bindings-map (kbd "C-c C-q")
   ;;     '(lambda ()
   ;;        (interactive)
   ;;        (focus-mode 1)
   ;;        (focus-read-only-mode 1)))
   (with-eval-after-load 'org
     (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
   #+END_SRC

   Lastly we need to activate the map by creating and activating the
   =minor-mode=.

   #+BEGIN_SRC emacs-lisp
   (define-minor-mode custom-bindings-mode
     "A mode that activates custom-bindings."
     t nil custom-bindings-map)
   #+END_SRC

* License
